mailto(kaiv@wakkanet.fi)

htmlcommand(
<insert file=../../es-makrot.txt>
<insert name=ecasound_subindexbar>

<hr>
<p>
<center><h2>Ecasound documentation - Programmer's guide</h2></center>
</p>
)

article()
       (Kai Vehmanen)
       (11102000)

COMMENT(----------------------------------------------------------------)
COMMENT(----------------------------------------------------------------)
sect(Preface)
This document describes how ecasound library works, how to use it,
how to extend and add features to it and so on. Before reading this
document, you should first look at other available documentation
(especially url(ecasound users's guide)(../users_guide/users_guide.html)).

Unlike most web pages, this document really is under construction. :)

COMMENT(----------------------------------------------------------------)
COMMENT(----------------------------------------------------------------)
sect(General guidelines)

COMMENT(----------------------------------------------------------------)
subsect(Design and programming)
subsubsect(Open and generic design)
Over the years ecasound's core design has been revised many times.
After rewriting some code sections hundreds of times, you start
to appreciate genericity. :) Although specific use-cases are used
for testing new ideas, they are just design aids.

subsubsect(Object-orientation)
Ecasound is written in C++ (as specified in 1997 ANSI/ISO C++ standard). 
Because C++ language itself doesn't force you to follow OO-principles, 
I often use Eiffel language as a reference when designing classes and 
routines.

subsubsect(Data hiding) 
This OO-feature deserves to be mentioned separately. Whenever 
possible, I always try to hide the actual data representation. 
This allows you to make local implementation changes without
affecting other parts of the code base. One thing I've especially 
tried to avoid is excessive use of pointer magic.

subsubsect(Design by contract) 
Design by contract means that when you write a new routine,
in addition to the actual code, you also describe routine's 
behaviour as accurately as possible.

Routine must specify all requirements and assumptions. 
If the caller violates this specification, routine is not 
responsible for the error. This means that routine mustn't
check argument validity. This must be done by the caller.

Routine should also specify, what conditions are true when
returning to the caller. By doing this, routine ensures that
it works correctly and calling routine knows what is happening.

Ideally, these conditions prove that the routine works correctly. 
The benefits of this approach should be clear. When you call 
a well-defined routine, a) you know what parameter values it 
accepts, b) you know what it does to them and c) if errors occur, 
it's easier to pinpoint the faulty routine. In practice this is 
done by using comments and pre/postconditions. As C++ doesn't 
directly support pre/postconditions, I've simulated them using
the class DEFINITION_BY_CONTRACT from kvutils package and with 
normal assert() calls.

subsubsect(Routine side effects) 
I try to make a clear distinction between routines that 
have side-effects (=methods, processors, modifiers; routines that
change object's state) and const routines (=functions, observers).

subsubsect(Sanity checks)
Sanity checks are done only to prevent crashes. All effects
and operators happily accept "insane" parameters. For instance 
you can give -100.0% to the amplifier effect. This of course 
results in inverted sample data. I think this a reasonable 
approach. After all, ecasound is supposed to be a tool for creative
work and experimenting. It's not meant for e-commerce. ;)

subsubsect(Error handling)
Two specific things worth mentioning: First, the standard UNIX-style 
error handling, where functions performing actions return an integer 
value, is em(not) used in ecasound. As described in the above section 
em(Routine side effects), all routines are either modifiers or
observers, not both. So when using ecasound APIs, you first perform an
action (modifying function), and then afterwards check what happened
(using an observer function).

Secondly, C++ exceptions are used in ecasound. Exception based error
handling has its problems, but in some cases it is clearly the best
option. Using exceptions for anything other than pure exception
handling is to be avoided at all cost. And when exceptions are used,
their use must be specified in function prototypes. This is important,
as clients need to know what exceptions can be thrown. All in all, use 
of exceptions should be carefully planned.

COMMENT(----------------------------------------------------------------)
subsect(Coding style)
subsubsect(General guide lines)
Variable names are all lower case and words are separated with
underscores (int very_long_variable_name_with_underscores). Class data
members are marked with em(_rep) postfix. Data members which are
pointers are marked with em(_repp). Index-style short variable names 
(em(n), em(m), etc.) are only used in local scopes. Enum types 
have capitalized names (em(Some_enum)).

subsubsect(Package specific)
startdit()
dit(libecasound, ecasound, ecatools, libkvutils)
Class names are all in upper case and words separated with underscores
(class ECA_CONTROL_BASE). This a standard style in Eiffel programming.

dit(libqtecasound, qtecasound, ecawave)
Qt-style is used when naming classes (class QELevelMeter), otherwise
same as above.
enddit()

COMMENT(----------------------------------------------------------------)
subsect(Documentation style)
Javadoc-style class documentation is the preferred style.
Class members can be documented either when they are declared (header
files), or when they are defined. Especilly when specifying
complicated interfaces, it's better to put documentation in the
definition files. This way the header files remain compact and serve 
better as a reference. 

Here's a few general documentation guide lines:
startdit()
dit(Use of 3rd person) 
"Writes samples to memory." instead of "Write samples to memory."
dit(Sentences start with a verb)
"Writes samples to memory." instead of "Samples are written to memory."
dit(This instead of the)
"Get controllers connected to this effect." instead of "Get controllers connected to the effect.
enddit()

COMMENT(----------------------------------------------------------------)
subsect(Versioning)
All ecasound releases have a distinct version number. In addition, 
every released version is marked either with 'd' (development) 
or 'r' (stable release). For instance, you could have development 
releases 0.1d1, 0.2d1 and 0.3d1. When the development reaches a stable 
status, 0.4r1 will be released. After this, a new development series 
will start (0.5d2, and so on).

Separation between development and stable releases is very important,
because it affects library versioning. The idea is that all library
interfaces are versioned separately with libtool. If during
development changes are made to the public interfaces, a new interface
version is created. The new interface version won't be frozen until the 
next stable version. After this, no changes to the interface (affects
both at binary and source level) are allowed. If these changes must be 
made, a new interface version must be created. It's important to note
that interface compatibility is not guaranteed between development
releases. So if you are linking apps against development versions of
ecasound libraries, you must be prepared for interface changes.

All changes in the public interfaces are documented in library
specific em(ChangeLog) files. These files are usually located in the
top-level source directory.

COMMENT(----------------------------------------------------------------)
COMMENT(----------------------------------------------------------------)
sect(How ecasound works?)

COMMENT(----------------------------------------------------------------)
subsect(Common use-cases)
Here's some common cases how ecasound can be used.

subsubsect(Simple non-interactive processing)
One input is processed and then written to one output. This includes effect 
processing, normal sample playback, format conversions, etc.

subsubsect(Multitrack mixing)
Multiple inputs are mixed into one output.

subsubsect(Realtime effect processing)
There's at least one realtime input and one realtime output.
Signal is sampled from the realtime input, processed and
written to the realtime output.

subsubsect(One-track recording)
One input is processed and written to one or more outputs.

subsubsect(Multitrack recording)
The most common situation is that there are two separate
chains. First one consists of realtime input routed to a
non-realtime output. This is the recording chain. The
other one is the monitor chain and it consists of one or
more non-realtime inputs routed to a realtime output.
You could also route your realtime input to the monitoring
chain, but this is not recommended because of severe
timing problems. To synchronize these two separate chains,
ecasound uses a special multitrack mode (which should be
enabled automatically).

subsubsect(Recycling a signal through external devices)
Just like multirack recording. The only difference is
that realtime input and output are externally
connected.

COMMENT(----------------------------------------------------------------)
subsect(Signal flow)
This is simple. A group of inputs is routed to a group of chains.
Audio data is processed in the chains and afterwards routed to 
a group of outputs. Using internal loop devices, it' also possible to 
route signals from one chain to another. It's also possible to assign
inputs and outputs to multiple chains.

COMMENT(----------------------------------------------------------------)
subsect(Control flow)
subsubsect(Passive operation)
When ecasound is run in passive mode, the program flow is simple.
A ECA_SESSION object is created with suitable parameters, it is
passed to a ECA_PROCESSOR object and that is all. Once engine
is started, it does the processing and exits. 

Another way to do passive processing is to create a ECA_CONTROL 
object and use it to to access and modify the ECA_SESSION object 
before passing it to ECA_PROCESSOR.

subsubsect(Interactive operation)
In interactive mode, everything is done using the interface provided
by ECA_CONTROL. This is when things get complex:

ECA_SESSION object can contain many ECA_CHAINSETUP objects, but
only one of them can be active. On the other hand it is possible
that there are no chainsetups. If this is the case, about the
only thing you can do is to add a new chainsetup. 

When some chainsetup is activated, it can be edited using the
interface provided by ECA_CONTROL. Before actual processing can
start, the chainsetup must first be connected. Only valid 
chainsetups (at least one input-output pair connected to the same
chain) can be connected. 

startdit()
ECA_CHAINSETUP can be...
startdit()

dit(not selected) - can't be accessed from ECA_PROCESSOR
dit(selected, invalid) - can be edited (files and devices are not opened)
dit(selected, valid) - can be connected (files and devices are not opened)
dit(connected) - ready for processing (files and devices are opened before connecting)

enddit()
enddit()

startdit()
ECA_PROCESSOR status is one of...
startdit()

dit(not_ready) - ECA_SESSION object is not ready for processing or
ECA_PROCESSOR hasn't been created
dit(running) - processing
dit(stopped) - processing hasn't been started or it has been stopped
before completion
dit(finished) - processing has been completed

enddit()
enddit()

COMMENT(----------------------------------------------------------------)
subsect(Class descriptions)

The primary source for class documentation is header files.
A browsable version of header documentation is at
url(www.wakkanet.fi/~kaiv/ecasound/Documentation/doxygen_pages.html)(http://www.wakkanet.fi/~kaiv/ecasound/Documentation/doxygen_pages.html)
Anyway, let's look at the some central classes.

COMMENT(----------------------------------------------------------------)
subsubsect(Core) 
subsubsubsect(ECA_PROCESSOR) 
ECA_PROCESSOR is the actual processing engine. It is initialized with
a pointer to a ECA_SESSION object, which has all information needed at
runtime. Processing is started with the exec() member function and
after that, ECA_PROCESSOR runs on its own. If the interactive mode is
enabled in ECA_SESSION, ECA_PROCESSOR can be controlled using the
ECA_CONTROL class. It offers a safe way to control ecasound.
Another way to communicate with ECA_PROCESSOR is to access the
ECA_SESSION object directly.

subsubsubsect(ECA_SESSION) 
ECA_SESSION represents the data used by ecasound. A session contains
all ECA_CHAINSETUP objects and general runtime settings (iactive-mode,
debug-level, etc). Only one ECA_CHAINSETUP can be active at a time. To
make it easier to control how threads access ECA_SESSION, only
ECA_PROCESSOR and ECA_CONTROL classes have direct access to
ECA_SESSION data and functions. Other classes can only use em(const)
members of ECA_SESSION. 

subsubsubsect(ECA_CONTROL) 
ECA_CONTROL represents the whole public interface offered by 
ecasound library. It also has a simple command interpreter 
(interactive-mode) that can used for controlling ecasound. 

COMMENT(----------------------------------------------------------------)
subsubsect(Data objects)

subsubsubsect(SAMPLEBUFFER)
Basic unit for representing sample data. The data type used to 
represent a single sample, valid value range, channel count, global 
sampling rate and system endianess are all specified in 
"samplebuffer.h" and "sample_specs.h".

subsubsubsect(DEBUG)
Virtual interface class for the debugging subsystem. Ecasound engine 
sends all debug messages to an instance of this class. The actual 
implementation can be done in many ways. For example in the console mode
user-interface  of ecasound, TEXTDEBUG class is used to implement the DEBUG
interface. It sends all messages that have a suitable debug 
level to the standard output stream. On the other hand, in qtecasound 
DEBUG is implemented using a Qt widget. New DEBUG implementations can
be registered at runtime with the em(attach_debug_object()) call
(declared in eca-debug.h).

COMMENT(----------------------------------------------------------------)
subsubsect(Object maps)
Object maps are a central repositories for commonly used objects.
When object is registered to a map, a regular expression is attached 
to it. When object map receives a request for a new object, it 
goes through all registered regular expressions, and returns an 
object attached to the matching expression. Object maps can also provide
a list of all registered objects. 

This system may sound a bit complex, but in practise it is quite
simple and makes a lot of things more easier. For instance, when
adding new object types to the library, you only have to add a call
which registers the new object; no need to modify any other part of 
the library. It also makes it possible to add new types at runtime. For
instance, an application linked against libecasound might add its own
custom object types on startup. All parts of libecasound can use the
custom objects, although they are not part of library itself.

All objects defined in libecasound are registered in the file
em(eca-static-object-maps.cpp).

subsubsubsect(ECA_OBJECT)
A virtual base class that represents one object. All classes deriving 
from ECA_OBJECT can be registered to object maps.

subsubsubsect(ECA_OBJECT_MAP)
This is the basic object map implementation. It offers map services
for ECA_OBJECT objects.

subsubsubsect(ECA_PRESET_MAP)
Special class that inherits from ECA_OBJECT_MAP. This class is used
for mapping instances of class PRESET.

subsubsubsect(ECA_AUDIO_OBJECT_MAP)
A convenience class for mapping AUDIO_IO objects. Handles the casting 
between ECA_OBJECT<->AUDIO_IO.

subsubsubsect(ECA_CHAIN_OPERATOR_MAP)
A convenience class for mapping CHAIN_OPERATOR objects. Handles the casting 
between ECA_OBJECT<->CHAIN_OPERATOR.

subsubsubsect(ECA_CONTROLLER_MAP)
A convenience class for mapping GENERIC_CONTROLLER objects. Handles the casting 
between ECA_OBJECT<->GENERIC_CONTROLLER.

subsubsubsect(ECA_LADSPA_PLUGIN_MAP)
A convenience class for mapping EFFECT_LADSPA objects. Handles the casting 
between ECA_OBJECT<->EFFECT_LADSPA.

COMMENT(----------------------------------------------------------------)
COMMENT(----------------------------------------------------------------)

sect(Using ecasound from other programs)

COMMENT(----------------------------------------------------------------)
subsect(Console mode ecasound)
This is the easiest way to take advantage of ecasound features in your
own programs. You can fork ecasound, pipe commands to ecasound's
interactive mode or you can create chainsetup (.ecs) files and load
them to ecasound. You'll be able to do practically anything. The only 
real problem is getting information from ecasound. You'll have to
parse ecasound's ascii output if you want to do this. To make this 
a bit easier, ecasound offers the dump-* commands. These print
configration and status info as formatted text strings (easier to
parse than normal output).

COMMENT(----------------------------------------------------------------)
subsect(Controller class interface)
By linking your program to libecasound, you can use the ECA_CONTROL
class for controlling ecasound. This is a large interface class that
offers routines for controlling all ecasound features. It's easy
to use while still powerful. All ecasound interface programs use this 
class. Here's a few lines of code:

verb(
--cut--
ECA_SESSION esession;
ECA_CONTROL ctrl (&esession);
ctrl.new_chainsetup("default");
[... other setup routines ]
ctrl.start(); // starts processing in another thread (doesn't block)
--cut--
)

If you don't want to use threads, you can do as above, but use
ECA_PROCESSOR directly to do the actual processing. In other words, 
you only use ECA_CONTROL for setting up a ECA_SESSION object. This 
way the processing is done without additional threads. Here's a 
short sample:

verb(
--cut--
ECA_SESSION esession;
ECA_CONTROL ctrl (&esession);
ctrl.new_chainsetup("default");
[... other setup routines ]
ECA_PROCESSOR p (&esession);
p.exec(); // blocks until processing is finished
--cut--
)

COMMENT(----------------------------------------------------------------)
subsect(Ecasound classes as building blocks)
And of course, you can also use individual ecasound classes directly.
This means more control, but it also means more work. Here's
another short sample:

verb(
--cut--
- create a SAMPLE_BUFFER object for storing the samples
- read samples with an audio I/O object - for example WAVEFILE
- process sample data with some effect class - for example EFFECT_LOWPASS
- maybe change the filter frequency with EFFECT_LOWPASS::set_parameter(1, new_value)
- write samples with an audio I/O object - OSSDEVICE, WAVEFILE, etc.
--cut--
)

COMMENT(----------------------------------------------------------------)
COMMENT(----------------------------------------------------------------)

sect(Adding new features and components?)

COMMENT(----------------------------------------------------------------)
subsect(Audio objects)
To implement a new audio object type, you must first select which 
top-level class to derive from. Usually this is either AUDIO_IO
(the top-level class), AUDIO_IO_BUFFERED (a more low level interface)
or AUDIO_IO_DEVICE (realtime devices).

The second step is to implement the various virtual functions declared
in the parent classes. These functions can be divided into four
categories: 1) attributes (describes the object and its capabilities), 
2) configuration (routines used for setting up the object), 3) main 
functionality (open, close, input, output, etc) and 4) runtime
information (status info).

Adding the new object to ecasound is much like adding a new effect
(see the next section). Basicly you just add it to the makefiles and
then register it to the appropriate object map (see below).

COMMENT(----------------------------------------------------------------)
subsect(Effects and other chain operators)
Write a new class that inherits from CHAIN_OPERATOR or any of its
successors. Implement the necessary routines (init, set/get_parameter, 
process and a default constructor) and add your source files to
libecasound's makefiles. Then all that's left to do is to add your
effect to em(libecasound/eca-static-object-maps.cpp),
em(register_default_objects()). Now the new effect can be used just 
like any other ecasound effect (parameters control, effect presets, etc).

COMMENT(----------------------------------------------------------------)
subsect(Differences between audio objects and chain operators)
Design-wise, audio objects and effects (chain operators) aren't that 
far away from each other. Many audio apps don't separate these
concepts at all (for instance most UG based synthesizers). In ecasound 
though, there are some differences:

Input/output:
startit()
it() audio objects can be opened for reading writing or read&write
it() effects are modeless
it() audio objects read from, or write to a buffer
it() effects get a buffer which they operate (in-place processing)
endit()

Audio format:
startit()
it() audio objects have a distinct audio format (sample rate, bits,
     channels)
it() effects should be capable of accepting audio data in any format
     (this is usually easy as ecasound converts all input data to its
     internal format)
endit()

Control:
startit()
it() audio objects can be opened, closed, prepared, started and stopped
it() effects don't have a running state
endit()

Position:
startit()
it() audio objects have length and position attributes
it() effects just process buffers and don't know about their position
endit()

A good example of the similarity between the two types are LADSPA
oscillator plugins. Although they are effects, you can easily use them 
as audio inputs by specifying:

verb(
"ecasound -i null -o /dev/dsp -el:sine_fcac,440,1"
)

COMMENT(----------------------------------------------------------------)
subsect(LADSPA plugins)
Ecasound supports LADSPA-effect plugins (Linux Audio Developer's Simple
Plugin API). See url(LAD mailing list web site)(http://www.linuxdj.com/audio/lad) for 
more info about LADSPA. Other useful sites are 
url(LADSPA home page)(http://www.ladspa.org) and
url(LADSPA documentation)(http://www.ffem.org/gdam/ladspa-doc/ladspa.html).

htmlcommand(<insert name=ecasound_tail>)
