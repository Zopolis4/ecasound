\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{html}
\hfuzz=4pt % don't fuss when less than 4pt
\input{/usr/share/yodl/xlatin1.tex}
\setlength{\parskip}{3mm} % height between par
\setlength{\parindent}{0mm} % no par indent

\bodytext{link="#662a00" vlink="#666655" bgcolor="#ffffff"}

\title{Ecasound User's Guide}
\author{Kai Vehmanen}
\date{03102001}
\begin{document}

\maketitle
\tableofcontents 
\clearpage


\section{Preface}

This document describes ecasound's use from user's point of view. 
In addition to the actual user/client-programs, all essential ecasound 
library concepts and features are also discussed. To avoid duplicating
documentation, I've used references to other sources whenever suitable. 
For instance, ecasound's man pages are in a very good shape.
They are also available in HTML-format.



\section{Introduction}

\subsection{What is ecasound?}

Ecasound is a software package designed for multitrack audio
processing. It can be used for simple tasks like audio playback, 
recording and format conversions, as well as for multitrack effect 
processing, mixing, recording and signal recycling. Ecasound supports 
a wide range of audio inputs, outputs and effect algorithms. 
Effects and audio objects can be combined in various ways, and their
parameters can be controlled by operator objects like oscillators 
and MIDI-CCs. As most functionality is located in shared libraries,
creating alternative user-interfaces is easy. A versatile console mode
interface is included in the package.

\subsection{History}

I've programmed ecasound for my own recording purposes. The first 
versions ran under IBM Os/2. I used them for finalizing my analog 
4-track recordings. My 4-track was a nice tool, but it had its limits.
So eventually I started to use Windows-based multitrack software. I
still used ecasound for fx processing and finalizing. When I 
ported ecasound to Linux, a lot of the code was rewritten from 
scratch. During this I also added multitrack capabilities
to ecasound. It took a lot of work, but in the end I was able to 
get rid of all my Windows recording software. Nowadays I use 
ecasound for all my music projects. Because of this, I also 
continue to improve and develop ecasound.



\section{Ecasound library concepts}

\subsubsection{Chain}
Chain is a simple signal flow abstraction. Every chain has one input
and one output. All chain operators and their controllers are attached
to chains. Chain can be muted and bypassed.

\subsubsection{Audio object}
Audio object is a really generic concept. Practically anything that 
is able to produce or receive audio data can be an ecasound audio 
object. Currently there's support for soundcard drivers/subsystems, 
various file formats and various types of data-piping.
Notice that objects can be used both for input and output.

\subsubsection{Chain operators and controllers}
Chain operators are used to process and analyze sample data.
Controllers are used to control individual chain operator parameters.
Both types of objects are attached to chains. Term \emph{chain object} refers
to all objects that can be attached to chains - ie. operators and 
controllers.

\subsubsection{Chainsetup}
Chainsetup is the central data object. All other objects (inputs,
outputs, chains, etc) are connected to some chainsetup. There can be 
many chainsetups but only one can be connected. Similarly only
one chainsetup can be selected. Chainsetups are also used for
loading and saving state information. The format used is identical to 
the command-line syntax used by the console mode user-interface, which 
makes it easy to edit saved chainsetups. See
\texttt{ecasound(1)} for details.

\subsubsection{Concept of current position}
Only audio objects and chainsetups have a current position. When 
you change position of a chain, you're changing position of audio 
objects connected to that chain. Also, when you change chainsetup position,
all chains (= all audio objects attached to them) are affected.

\subsubsection{Interactive-mode}
Ecasound library can be controlled with simple commands. 
This is called the interactive-mode. All programs linked
to ecasound library can use this facility. 



\section{Using}


\subsection{Where to start?}
There's no one single way to use ecasound. You can use it as 
a simple glue component for doing tasks, which aren't handled by
other applications you are using, or because ecasound does these tasks
more easily. But ecasound can also serve as the centre of your studio 
setup, doing everything from effects processing to multitrack
recording and mixing. 

But this flexibility doesn't come for free. It's difficult to describe
ecasound's features in a few phrases. Because of this, I encourage
new users to start from ecasound \texttt{examples.html}
page. It isn't a perfect introduction, and definitely not the only way 
to use ecasound, but it does give an overall view of what can be done
with ecasound, and more importantly, that most tasks are actually
quite easy to perform.


\subsection{Creating ecasound chainsetups}
\subsubsection{General}
Here are a few rules that help writing valid chainsetups. Whether
you are writing chainsetup files (.ecs), using command-line arguments, 
using a graphical frontend, etc, these rules are always useful:

\begin{itemize}
\item Every chain has exactly \_one\_ input and \_one\_ output.
\item All inputs and outputs must be connected to some chain.
\item For every input/output, there must be exactly \_one\_
    input/output specification (example specification: '-i:file.ext').
\item All routing from/to chains is based on selecting a set of chains
    and then specifying an input or output (example: '-a:1,2 -i:file.ext').
\item All audio copying and mixing is done channel-wise. If you attach 
    a 4-channel input and a two-channel output to a chain, chain 
    will have 4 channels of audio, but only the first two channels
    will be written to the output file.
\end{itemize}



\subsubsection{Audio objects}


\paragraph{ewf - ecasound wave file}
Ecasound wave file (.ewf) is a simple wrapper format for controlling 
other audio objects. One important feature of ewf is the ability to seek
beyond end position. When first write operation is performed, current 
file position is stored into the .ewf file and the actual audio object
is opened for writing. When reading, you get silence until the offset 
position is reached. Shortly put, this is a practical way to save disk 
space when doing multitrack recording. Newer versions of ewf-format 
support looping, ranges, etc

Ewf-files themselves are simple ascii files that contain key-value pairs. The 
format used is the same as with ecasound resource files. See
\texttt{ecasoundrc(5)} manual page for more
info. Currently recognized keywords are:

\begin{itemize}
\item  source - audio object name {[}read,write{]}
\item  offset - insert audio object at offset (seconds) {[}read,write{]} 
\item  start-position - start offset inside audio object (seconds) {[}read{]}
\item  length - how much of audio object data is used (seconds) {[}read{]}
\item  looping - whether to loop sample data (true or false) {[}read{]}
\end{itemize}


subsubsubsubsect(Example of ewf use)
Let's take an example .ewf file:
\begin{verbatim} 

-- test.ewf --
source = test.wav
offset = 5.0
start-position = 2.0
length = 3.0
looping = true
--cut--
 
\end{verbatim} 

So what happens when you issue "ecasound -i test.ewf -o /dev/dsp". The
first 5 secs will be silent, then ecasound starts to read data from
test.wav (offset inside test.wav is 2 secs). After 8 secs (offset + 
length) of playback, we'll loop back to start (2 sec from beginning of 
test.wav).


\paragraph{Audio loop devices}
Loop devices were added to ecasound version 1.7.0. You use them like this:
\begin{verbatim} 

--cut--
# note, the second loop parameter is the loop id-number;
# it is used to associate loop inputs with correct loop outputs
ecasound -a:1 -i:some.mp3 -o:loop,1
         -a:2 -i:another.mp3 -o:loop,1
         -a:3 -i:loop,1 -o /dev/dsp -ea:200
--cut--
 
\end{verbatim} 

Both inputs are eventually routed to chain "3", where a -ea:200 is
applied to the signal. This does have one downside, loop device
adds latency (-b:x -> latency of x frames). 


\subsubsection{Chain operators}
See \texttt{ecasound(1)}.


\paragraph{Some examples of the use of gate operators}
Gates are just like any other chain operators. They are assigned to 
a chain, and process buffers of samples data. With gates you can
easily crop sections of audio files, and do automatic volume-based 
cropping. For instance.
\begin{verbatim} 

--cut--
###| /empty1 |$ ls -la guitar.wav
-rw-rw-r--   1 kaiv     kaiv     15790124 Sep 30 23:27 guitar.wav

###| /empty1 |$ ecasound_debug -i guitar.wav -o gate-test.wav -gc:60,1

###| /empty1 |$ ls -la gate-test.wav
-rw-rw-r--   1 kaiv     kaiv       180268 Dec 12 22:13 gate-test.wav
--cut--
 
\end{verbatim} 

This cut the section {[}60:00 sec -> 61:00 sec{]} from guitar.wav into
gate-test.wav. The old '-gc' would have just muted all audio outside the
{[}60,61{]} region. The threshold gate is used similarly:
\begin{verbatim} 

--cut--
###| /empty1 |$ ecasound_debug -i gate-test.wav -o gate-test-rms.wav -ge:11.2,5,1

###| /empty1 |$ ecasound_debug -i gate-test.wav -o gate-test-peak.wav -ge:5,5,0

###| /empty1 |$ ls -la gate*wav
-rw-rw-r--   1 kaiv     kaiv       163884 Dec 12 22:18 gate-test-peak.wav
-rw-rw-r--   1 kaiv     kaiv       143404 Dec 12 22:17 gate-test-rms.wav
-rw-rw-r--   1 kaiv     kaiv       180268 Dec 12 22:13 gate-test.wav
--cut--
 
\end{verbatim} 

In the first one, gate is opened when the RMS-volume goes over the 11.2\%
threshold, and closed when RMS-volume falls below 5\%. In the second,
both entry and close thresholds are 5\% (peak volume). 


\subsubsection{Controllers}
See \texttt{ecasound(1)}.


\subsubsection{Effect presets}
Ecasound has a powerful effect preset system that allows you to create
new effects by combining basic effects and controllers.

Presets can be stored into separate files or they can be stored
into a global database. Either way, the preset format is the same
(also see \texttt{ecasoundrc(5)} man page, 
the same parsing engine is used):
\begin{verbatim} 
preset_name = effects controllers | ... | effects controllers 
\end{verbatim} 

Effects and controllers are specified using the same format as 
used in command-line parsing (-ea:100, -kl:1,0,100,5, etc). You 
can add a new parallel chain using the pipe characher '\textbar '. '\textbackslash ' sign is 
used to continue preset definition on the next line.


\paragraph{Example of preset use}
Ecasound effect presets are in fact small ecasound engines pretending
to be effects. Here's an example of multi-chain effect preset:

\begin{verbatim} 

-- file 'bassbooster.ecp' --
# let's put the low freqs into one chain and high freqs in another
bassbooster = -efl:2000 -ea:200 | -efh:2000 -ea:50
# note, the '|' sign separates parallel chains
--cut--
 
\end{verbatim} 


Once defined, you can use the preset in the following way:
\begin{verbatim} 

--cut--
ecasound -a:1 -i:some.mp3 -pf:bassbooster.ecp
         -a:2 -i:another.mp3 -pf:bassbooster.ecp
         -a:1,2 -o:/dev/dsp
--cut--
 
\end{verbatim} 



\subsubsection{LADSPA plugins}
Ecasound supports LADSPA-effect plugins (Linux Audio Developer's Simple
Plugin API). See \texttt{ecasound(1)} for more
info.


\subsection{Configuration}
User preferences are stored to \emph{\textasciitilde /.ecasouncrc}. See 
\texttt{ecasoundrc(5)} manual page for more 
info.

By default, files for effects and oscillator presets are 
in \emph{/usr/local/share/ecasound}.



\section{User interfaces}

Probably the best place to start is the examples section of 
ecasound HTML-documentation: \texttt{examples.html}.


\subsection{ecasound}
See \texttt{ecasound(1)}.


\subsection{ecatools}
See \texttt{ecatools(1)}.

\section{Miscellanous}

\subsection{Security considerations when running with root priviledges}

When given the -r option (raise priority), ecasound tries to raise 
its scheduling priority (to so called SCHED\_FIFO realtime scheduling)
and to avoid swapping, locks all its memory. To do this,
root-priviledges are required. So either ecasound has to be run as
root (logged in as root, or using the 'sudo' program), or it has to be
installed with the suid-root bit set. Now is this a safe thing to do?

Although there are no known vulnerabilities, setting ecasound suid-root is
not safe. Whether this is a real problem depends on the particular setup
(whether connected to network or not, any untrusted users with shell
access, ...).

The root of the problem is that ecasound (or at least 2.0 and earlier) 
doesn't contain any code for altering priviledge levels. If it is runs 
with root-priviledges, it does everything as root - including forking
external programs such as mp3 and ogg utilities and editors.
 
But all in all, this shouldn't be that big of an issue. For noncritical
uses, just don't set the suid-bit, but run as a normal user. If you have
an untrusted setup, you don't want to login as root, but still need 
to run in raised-priority mode, the following helps a bit (execute as 
root):

\begin{verbatim} 
        cd /usr/local/bin
        chown root.ecausers ecasound
        chmod 4750 ecasound
\end{verbatim} 

In other words, ecasound binary is set as suid-root (so it is run with
root-priviledges), but only root and members of the 'ecausers' groups can   
start it. Now just add all trusted ecasound users to the group and you are
set.

The ideal solution would be that ecasound would not need to be run with
full root-priviledges, only with priviledges for changing scheduling and
locking memory. Tommi Ilmonen's (author of the Mustajuuri softsynth)
givertcap program solves this very elegantly, but unfortunately it 
requires a custom kernel patch (at least for now). You can check the 
program at: 'http://www.tml.hut.fi/~tilmonen/givertcap/'. Ecasound 
doesn't yet have support for givertcap.

\end{document}